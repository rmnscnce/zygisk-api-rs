## Companion Process

Beyond running code directly within Zygote or application processes, Zygisk provides a mechanism for modules to launch and interact with a **companion process**. This is a separate Linux process spawned by Zygisk specifically for the module, offering unique capabilities and isolation.

### Conceptual Basis

*   **What is it?**
    A companion process is a distinct process, running under its own PID, that is associated with a Zygisk module. Zygisk itself manages the launching of this process based on the module's request.

*   **Why is it needed?**
    The companion process serves several important purposes:
    1.  **Privilege Separation and Different Execution Context:**
        *   The main code of a Zygisk module (e.g., in `post_app_specialize`) runs with the same privileges and SELinux context as the process it's loaded into (e.g., an application's UID and context, or Zygote's context).
        *   A companion process can be configured by Magisk/Zygisk to run with different credentials, most notably as **root (UID 0)** and potentially with a specific, more permissive (or sometimes more restricted) SELinux context. This is a cornerstone of many Magisk modules that need to perform system-level operations requiring root privileges without granting those privileges to every app process the module injects into.
        *   For example, a module might need to read system files or modify settings that are only accessible to root. The companion process can perform these actions, while the module code running in an app process operates with standard app privileges.

    2.  **Offloading Long-Running or Blocking Tasks:**
        *   Callbacks like `pre_app_specialize` in Zygote are on the critical path for application startup. Any significant delay in these callbacks can slow down app launches or even the entire system boot process.
        *   If a module needs to perform tasks that might block for an extended period (e.g., network requests, complex file I/O, intensive computations), these tasks can be offloaded to the companion process. This ensures the main Zygisk hooks in Zygote and app processes remain fast and responsive.

    3.  **Maintaining Independent State or Services:**
        *   The companion process has its own lifecycle, generally starting when Zygisk initializes or when first requested, and potentially running as long as Zygote is alive (though its exact lifecycle can be managed by Zygisk). This is independent of any single application process.
        *   It can be used to:
            *   Maintain global state for the module that needs to be shared or accessible across different app processes where the module is loaded.
            *   Run background services or daemons.
            *   Manage resources that should have a single instance (e.g., a shared database connection, a listening socket).

### Setting Up a Companion Process

The `zygisk-api` crate simplifies the setup of a companion process using a macro:

*   **The `register_companion!(my_companion_handler_fn);` Macro:**
    *   **Role:** This macro is used in the module's Rust code to designate a specific Rust function as the entry point for its companion process.
    *   **Function Signature:** The specified function (e.g., `my_companion_handler_fn`) must have a compatible signature, which typically involves receiving a file descriptor for communication. A common signature is `fn my_companion_handler_fn(socket_fd: std::os::unix::io::OwnedFd)`.
    *   **Generated Code:** Similar to `register_module!`, this macro generates the necessary `extern "C"` FFI boilerplate. It creates a C-ABI compatible function (e.g., named `zygisk_companion_entry` by convention) that Zygisk can discover and invoke to start the companion logic in the new process.

*   **How Zygisk Launches the Companion:**
    *   When Zygisk decides to start the companion for a module (often when the module is first loaded/initialized, or when `connect_companion()` is first called), it performs a `fork()` to create a new process.
    *   This new process is then configured according to the module's manifest or Magisk policies (e.g., set to run as UID 0, assigned a specific SELinux context).
    *   Zygisk then executes the `zygisk_companion_entry` function (generated by `register_companion!`) within this newly configured process. Zygisk also sets up a communication channel (a Unix domain socket pair) and passes one end of this socket to the `zygisk_companion_entry` function, which then passes it to the user-defined Rust companion handler function.

### Communication with the Companion Process

Interaction between the main module code (running in Zygote or an app) and its companion process is facilitated by Zygisk through a pre-established Unix domain socket.

*   **Socket-Based IPC (Inter-Process Communication):**
    *   Zygisk creates a Unix domain socket pair. One end is given to the companion process, and the other is made available to the module code running in other processes. This provides a direct, private communication channel.

*   **`ZygiskApi::connect_companion()`:**
    *   **Purpose:** When the module code (e.g., in `on_load` or `post_app_specialize`) needs to communicate with its companion, it calls the `api.connect_companion()` method (available on `ZygiskApi` instances, potentially from Zygisk API v2 onwards or as provided by the crate for all versions).
    *   **Return Value:** This function returns a file descriptor representing the module's end of the communication socket (e.g., as `std::os::unix::io::OwnedFd` or a raw `c_int`). This FD can then be wrapped (e.g., in a `std::os::unix::net::UnixStream`) for reading and writing.
    *   If the companion process is not already running, Zygisk typically attempts to launch it when `connect_companion()` is called for the first time.

*   **Companion's Entry Function Argument:**
    *   As mentioned, the Rust function registered with `register_companion!` (e.g., `my_companion_handler_fn`) receives the other end of the socket as an argument (e.g., `socket_fd: OwnedFd`). This is its dedicated channel for receiving requests from and sending replies to the module's main code.

*   **Data Serialization and Protocol:**
    *   **Developer Responsibility:** Zygisk only provides the raw byte stream (the socket). The module developer is entirely responsible for defining and implementing the communication protocol over this socket.
    *   This includes:
        *   Defining message structures (what constitutes a request or a response).
        *   Serializing data before sending (e.g., converting structs to byte arrays using libraries like `serde` with `bincode`, or using JSON, Protocol Buffers, or simply custom byte formats).
        *   Deserializing data upon receiving.
        *   Handling message framing, request/response synchronization, and error conditions within the protocol.

### Typical Use Cases

1.  **Querying Privileged Information / Performing Privileged Actions:**
    *   A module running in `post_app_specialize` (with app privileges) needs to read a system configuration file that only root can access.
    *   The app-side module code sends a request message (e.g., "get_config /path/to/file") over the socket to its companion.
    *   The companion process (running as root) receives the request, performs the privileged file read, and sends the file's content (or an error status) back to the app-side module.

2.  **Running Background Services:**
    *   A module wants to monitor system-wide network activity or log specific events independently of any single application.
    *   The companion process can host this service, performing tasks like packet sniffing (if capabilities allow), data aggregation, or periodic checks. It can then communicate relevant information back to module instances in apps if needed or log data to a central location.

3.  **Centralized Resource Management:**
    *   A module needs to maintain a shared database, cache, or set of rules that all its instances (across different apps) should use.
    *   The companion process can manage this central resource, ensuring data consistency and controlled access. Module instances in apps would then query or update the companion via IPC.

### Security Considerations

Using a companion process, especially one running with elevated privileges, introduces important security considerations:

*   **Privilege Boundaries:**
    *   Be extremely cautious when the companion process has higher privileges (e.g., root) than the module code calling it (e.g., app context). Any vulnerability in the companion's IPC handling logic could potentially be exploited for privilege escalation by a malicious app that can trigger requests through the module.
    *   **Principle of Least Privilege:** Design the IPC interface exposed by a privileged companion to be as minimal as possible. Only expose the specific functionalities required, rather than a generic "run command as root" or "read any file" interface.

*   **Data Validation:**
    *   Thoroughly validate and sanitize all data received over the socket on **both ends**, but especially in the more privileged companion process. Malformed or maliciously crafted data could lead to crashes, buffer overflows, or other vulnerabilities if not handled carefully.
    *   Define a clear, strict, and well-understood communication protocol.

*   **Companion Lifecycle and Reliability:**
    *   The companion process might be killed by the system (e.g., due to low memory conditions) or it might crash due to an internal bug. Zygisk may or may not automatically restart it.
    *   Module code using `connect_companion()` should be resilient to connection failures and potentially implement retry logic or graceful degradation of functionality if the companion is unavailable.
    *   State held only in the companion's memory will be lost if it restarts. Consider using persistent storage (e.g., files in the module's directory) if state needs to survive restarts.

*   **SELinux Contexts:**
    *   Even if a companion process runs as root, its capabilities are still governed by its SELinux context. Modules often need to provide custom SELinux rules (e.g., in a `sepolicy.rule` file within the Magisk module) to grant their companion process the specific permissions it needs to access certain resources or perform certain actions.

*   **Denial of Service (DoS):**
    *   If the module code running within an app can be influenced by the app itself, a malicious app might try to spam the companion process with numerous or malformed requests. This could potentially lead to resource exhaustion (CPU, memory, file descriptors) in the companion. Consider if rate limiting or other DoS mitigation strategies are necessary for your IPC protocol.

The companion process is a powerful feature for extending Zygisk module capabilities, but it demands careful IPC design and a strong focus on security to prevent vulnerabilities and ensure stability.
