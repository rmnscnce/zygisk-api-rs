## Module Lifecycle and Callbacks

Understanding the lifecycle of a Zygisk module—from how it's discovered and loaded by Zygisk, to how it registers itself, and finally, the sequence of callback functions it receives—is crucial for effective module development. This section details these stages.

### Zygisk Module Loading Process

1.  **Discovery and Loading:**
    *   When Zygote (or an application process, if Zygisk is "late-loading" into it) starts, the Zygisk component within Magisk identifies all installed and enabled Zygisk modules.
    *   Modules are typically packaged as APK files. Zygisk locates the native shared library (`.so` file) within the module's APK (e.g., in `lib/<architecture>/lib<module_name>.so`).
    *   Zygisk then uses the system's dynamic linker (e.g., `dlopen()`) to load this native library into the current process's address space.

2.  **Entry Point Invocation:**
    *   After successfully loading the library, Zygisk looks for a specific C function symbol within it. By convention, and as implemented by the `zygisk-api` crate, this entry point function is named `zygisk_module_entry`.
    *   The `register_module!(MyModuleType, MyZygiskVersion)` macro in `zygisk-api` is responsible for generating this `extern "C" fn zygisk_module_entry(...)` function.
    *   Zygisk invokes `zygisk_module_entry`, passing it initial arguments. These typically include:
        *   A pointer to a Zygisk API function table (e.g., `zygisk_api_table_vX*`). This table contains function pointers that the module can use to call back into Zygisk. The version of this table corresponds to the highest API version supported by the running Zygisk framework.
        *   A pointer to the JNI environment (`JNIEnv*`) for the current thread in the current process.

### Module Registration Process (within `zygisk-api`)

The code generated by the `register_module!` macro, specifically within the `zygisk_module_entry` function, handles the critical task of registering the Rust module with the Zygisk framework.

1.  **Module Instantiation:** An instance of the user's struct (e.g., `MyModule`) that implements `ZygiskModule<Version>` is created. This instance will hold any state for the module.

2.  **Internal Wrapper (`RawModule`):** The user's module instance, along with the Zygisk API table pointer and `JNIEnv` pointer received from Zygisk, are typically stored in an internal wrapper struct (let's call it `RawModule` for this explanation). This wrapper is what will be passed to the C-style callback shims.

3.  **ABI Preparation (`ModuleAbi`):**
    *   The core of registration involves providing Zygisk with a set of function pointers that correspond to the module's implementations of the lifecycle callbacks (e.g., `pre_app_specialize_fn`, `post_app_specialize_fn`).
    *   The `ZygiskRaw` trait, implemented by the chosen `Version` type (e.g., `raw::v5::V5`), defines an associated type `ModuleAbi`. This `ModuleAbi` is a C-compatible struct containing fields for these function pointers.
    *   The `Version::abi_from_module(&mut raw_module_instance)` method is called. This version-specific function populates an instance of `Version::ModuleAbi`. It sets the function pointer fields in `ModuleAbi` to point to thin `extern "C"` wrapper functions (shims). These shims are also generated by the crate and are responsible for:
        *   Retrieving the Rust `RawModule` instance.
        *   Creating a safe `ZygiskApi<Version>` wrapper for the current context.
        *   Calling the appropriate Rust method on the user's `ZygiskModule` implementation (e.g., the shim for `pre_app_specialize_fn` calls `my_module.pre_app_specialize(...)`).

4.  **Informing Zygisk:**
    *   The populated `ModuleAbi` instance (now containing pointers to the Rust callback shims) and the `API_VERSION` constant from the chosen `Version` (e.g., `raw::v5::V5::API_VERSION`) are passed to Zygisk's internal module registration function. This is often done via a function pointer like `Version::register_module_fn` obtained from the Zygisk API table.
    *   This step effectively tells Zygisk:
        *   "A module is loading."
        *   "It targets Zygisk API version `X`."
        *   "Here are the C function pointers to call for its lifecycle events (`pre_app_specialize`, `post_app_specialize`, etc.), according to the ABI of version `X`."

If this registration is successful, Zygisk considers the module active for the current process and will subsequently invoke its callbacks. The first callback typically received after successful registration is `on_load`.

### `ZygiskModule<Version>` Callbacks Explained

The methods of the `ZygiskModule<Version>` trait are the heart of a module's interaction with Zygisk. The `Version` type parameter (e.g., `raw::v5::V5`) ensures that the `api` object and `args` structures are correctly typed for the Zygisk API version the module is compiled against. `JNIEnv` is typically accessible via `api.get_jni_env()` within these methods.

1.  **`on_load(&self, api: ZygiskApi<Version>, _module_apk: Option<std::fs::File>)`**
    *   **When Called:** This is the first callback invoked on your module instance right after it has been successfully loaded and registered by Zygisk. It's called in every process where the module is loaded (Zygote, individual app processes, system_server).
    *   **Purpose:** Ideal for one-time initializations:
        *   Setting up global state for the module.
        *   Allocating resources that the module will need throughout its lifetime in the current process.
        *   Loading configuration files from the module's directory.
        *   Performing initial JNI lookups (e.g., caching `jclass` or `jmethodID`s) if needed globally for this process.
    *   **`api: ZygiskApi<Version>`:** Provides methods to interact with Zygisk, such as logging (`api.log_i(...)`), getting the module's private data directory (`api.get_module_dir()`), or accessing the module's APK via a function like `api.get_module_apk()` (the `_module_apk` argument in the signature is illustrative of this capability).
    *   **`JNIEnv` Access:** Obtainable via `api.get_jni_env()`, allowing JNI operations if required at this stage (e.g., to interact with system classes or load assets).

2.  **`pre_app_specialize(&self, api: ZygiskApi<Version>, args: &mut Version::AppSpecializeArgs)`**
    *   **Context:** Called within the **Zygote process**. This occurs just *before* Zygote forks to create and specialize a new Android application process.
    *   **Purpose:** To observe or modify the properties of an application *before* it is launched. This is a powerful hook for system-wide modifications that need to affect an app from its very inception. Common uses:
        *   Changing the app's UID (`args.uid`), GID (`args.gid`), or supplementary groups (`args.gids`).
        *   Modifying the app's SELinux context (`args.se_info`).
        *   Altering process nice name (`args.nice_name`), runtime flags, or other process parameters.
        *   Preventing certain FDs from being closed by adding them to `args.fds_to_ignore` (if available in the API version).
    *   **`args: &mut Version::AppSpecializeArgs`:** A **mutable** reference to a struct containing the specialization arguments for the app. The exact fields depend on the Zygisk API `Version` (defined by `Version::AppSpecializeArgs`). Common fields include `uid`, `gid`, `gids`, `nice_name`, `se_info`, `app_data_dir`, `is_top_app`, etc. Modifying these fields directly changes the parameters Zygote will use to launch the app.

3.  **`post_app_specialize(&self, api: ZygiskApi<Version>, args: &Version::AppSpecializeArgs)`**
    *   **Context:** Called within the **newly forked application process**. This occurs *after* the app process has been specialized by Zygote (i.e., its UID, GID, SELinux context, etc., are set) but *before* any of the application's own Java/Kotlin code (like `ActivityThread.main` or `Application.onCreate`) has executed.
    *   **Purpose:** This is the most common place for modules to perform actions within the context of a specific target application. Uses include:
        *   Loading custom code (e.g., other native libraries via `dlopen`, or Java/Kotlin code via JNI) into the app's process.
        *   Setting up function hooks (e.g., using PLT hooking via `api.plt_hook_register()` or JNI hooking via `api.hook_jni_native_methods()`).
        *   Performing runtime modifications specific to this application.
    *   **`args: &Version::AppSpecializeArgs`:** An **immutable** reference to the specialization arguments. It provides information about the app that was just started (e.g., its process name, UID, data directory). The fields are the same as in `pre_app_specialize`, but they are read-only here as the specialization has already occurred.

4.  **`pre_server_specialize(&self, api: ZygiskApi<Version>, args: &mut Version::ServerSpecializeArgs)`**
    *   **Context:** Called within the **Zygote process**. This occurs just *before* Zygote forks to start the Android System Server process.
    *   **Purpose:** Similar to `pre_app_specialize`, but specifically for the System Server. The System Server is a critical Android component hosting many core system services. Modifications here are very powerful and can have wide-ranging effects on the entire system.
    *   **`args: &mut Version::ServerSpecializeArgs`:** A **mutable** reference to a struct containing specialization arguments for the System Server. The type `Version::ServerSpecializeArgs` is defined by the `ZygiskRaw` trait for the chosen `Version`.

5.  **`post_server_specialize(&self, api: ZygiskApi<Version>, args: &Version::ServerSpecializeArgs)`**
    *   **Context:** Called within the **newly forked System Server process**. This occurs *after* the System Server process has been specialized but *before* its main services are fully initialized and running.
    *   **Purpose:** To perform actions within the context of the System Server. This could involve hooking functions within system services, modifying system behavior, or loading custom code into the System Server.
    *   **`args: &Version::ServerSpecializeArgs`:** An **immutable** reference to the specialization arguments for the System Server, providing context about its setup.

**Key Emphasis on Versioning:**
It's crucial to remember that the exact structure of `AppSpecializeArgs` and `ServerSpecializeArgs` (and any other version-dependent types like `ApiTable`) is determined by the `Version` parameter (e.g., `raw::v5::V5`) chosen by the developer when implementing `ZygiskModule<Version>` and registering with `register_module!`. This is made possible by the associated types defined in the `ZygiskRaw` trait, ensuring type safety and compatibility with the targeted Zygisk API version. The `ZygiskApi<Version>` instance provided to each callback is also tailored to this specific version.
